import { dirname, resolve } from "path"
import { spawnCommand } from "./util/spawnCommand"
import { constants, copyFile, readFile, writeFile } from "fs/promises"
import { dumpLog } from "."

export * from "./buildCommands"

/**
 * A builder-style class used to generate an image with tegra.
 */
export class TegraBuilder {
    public targetDevice?: string
    public bootPartitionDevice?: string
    public swapPartitionDevice?: string
    public rootPartitionDevice?: string
    public partPrefix: string = ""
    public swapEnabled = false
    public buildFragmentFolderCreated = false
    public swapSize = 0
    public quiet = false
    public readonly buildFunctions: (() => Promise<void>)[] = [ ]
    public readonly cleanupFunctions: (() => void)[] = [ ]
    public cleanupEnabled = true
    public fullLog: string = ""

    public async spawnChrootCommand(command: string) {
        return await this.spawnCommand("arch-chroot", [".tegra/rootfs", "bash", "-c", `${command}`], true)
    }

    public log(message: unknown, ...optionalParams: unknown[]) {
        this.fullLog += `${message}\n`
        if(this.quiet) return

        console.log(message, ...optionalParams)
    }

    public async spawnCommand(command: string, commandArgs: string[], superuser = false) {
        const commandOutput = await spawnCommand(command, commandArgs, superuser, this.quiet)

        this.fullLog += commandOutput

        return commandOutput
    }

    public noCleanup() {
        this.cleanupEnabled = false
        return this
    }

    /**
     * Adds a command (usually generated by a command factory) to the build process
     * 
     * @param command The command itself
     * @returns this
     */
    public add(command: (self: TegraBuilder) => void) {
        command(this)
        return this
    }

    /**
     * Installs a list of packages to the new system via pacstrap with the -KMc options
     * 
     * @param packageList The list of packages to pacstrap
     * @returns this
     */
    public pacstrapPackages(packageList: string[]) {
        this.buildFunctions.push(async () => {
            this.log(`Pacstrapping ${packageList.length} packages...`)
            await this.spawnCommand("pacstrap", ["-KMc", ".tegra/rootfs", ...packageList], true)
            this.log(`Pacstrapped ${packageList.length} packages!`)
        })

        return this
    }

    /**
     * Executes a command on the new system via arch-chroot
     * 
     * @param command The base command (e.g cat) to execute on the new system
     * @param commandArgs The arguments to provide to the command
     * @returns this
     */
    public executeCommand(command: string) {
        this.buildFunctions.push(async () => {
            this.log(`Executing ${command} in chroot...`)
            await this.spawnChrootCommand(command)
            this.log(`Executed ${command} in chroot successfully!`)
        })

        return this
    }

    /**
     * Creates/overwrites a file on the new system
     * 
     * @param patchPath The path to the file
     * @param targetPath The path to the file to apply the patch to, relative to the new system's root
     * @returns this
     */
    public applyPatch(patchPath: string, targetPath: string) {
        this.buildFunctions.push(async () => {
            this.log(`Applying ${patchPath} to ${targetPath}...`)
            const patchPathResolved = resolve(patchPath)
            const targetPathResolved = resolve(`.tegra/rootfs/${targetPath}`)

            await this.spawnCommand("mkdir", ["-p", dirname(targetPathResolved)], true)

            await copyFile(patchPathResolved,targetPathResolved)
            this.log(`Applied ${patchPath} to ${targetPath}!`)
        })

        return this
    }

    /**
     * Sets up the .tegra folder (where build fragments are stored)
     * 
     * @returns this
     */
    public createTegraFiles() {
        this.buildFragmentFolderCreated = true
        this.buildFunctions.push(async () => {
            this.log("Creating .tegra build fragment folder...")
            await this.spawnCommand("mkdir", ["-p", ".tegra/rootfs"])
            this.log("Created .tegra build fragment folder...")
        })

        return this
    }

    /**
     * Enables the swap partition with size ``swapSize``
     * 
     * @param swapSize The swap size to use (in MB)
     * @returns this
     */
    public enableSwap(swapSize = 2048) {
        if(this.targetDevice) throw new Error("Partition map already setup, use the enableSwap command before calling the useLoopbackDevice or useDisk build commands.")
        this.swapEnabled = true
        this.swapSize = swapSize

        return this
    }

    /**
     * Runs the build process, finalizes all configurations, and generates the final image
     */
    public async build(requireRoot = true) {
        if(requireRoot && (await this.spawnCommand("whoami", [], false)).trim() !== "root") throw new Error("The builder must be run with superuser permissions. Retry as root, or using sudo")

        for(let i = 0; i < this.buildFunctions.length; i++) {
            await this.buildFunctions[i]()
        }
        this.log("Built and wrote to the target disk sucessfully!")
    }

    /**
     * Manually cleans up, unmounting partitions, disabling swap, etc
     */
    public cleanup() {
        this.buildFragmentFolderCreated && this.add(dumpLog())

        for(let i = 0; i < this.cleanupFunctions.length; i++) {
            this.cleanupFunctions[i]()
        }
    }

    /**
     * Toggles output from this builder
     * 
     * @param quiet Whether or not the builder is quiet
     * @param sectioned Whether to make the entire build quiet, or just the commands up until quiet is disabled again (when)
     * @returns this
     */
    public setQuiet(quiet: boolean, sectioned = false) {
        if(!sectioned) this.quiet = quiet

        // We push to build functions to enable a build to be quiet in some sections and not quiet in others
        this.buildFunctions.push(async () => {
            this.quiet = quiet
        })

        return this
    }

    public constructor() {
        process.on("exit", async (ExitCode) => {
            if(!this.cleanupEnabled) return

            this.cleanup()

            process.exit(ExitCode)
        })
    }
}

process.on("SIGINT", () => {
    process.exit(1)
})

process.on("uncaughtException", (err) => {
    console.error(err)
    process.exit(1)
})
